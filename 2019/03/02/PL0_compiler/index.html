<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="keywords" content="hexo,ä¸ªäººåšå®¢,blog" />
  <meta name="description" content="AlfredZeeçš„ä¸ªäººåšå®¢" />
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://busuanzi.ibruce.info">
  <link rel="dns-prefetch" href="https://at.alicdn.com">
  
  <link rel="dns-prefetch" href="https://widget.daovoice.io">
  <link rel="dns-prefetch" href="https://widget-static-cdn.daovoice.io">
  <link rel="dns-prefetch" href="https://im.daovoice.io">
  
  
  <link rel="dns-prefetch" href="https://hm.baidu.com/">
  
  
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://api.github.com">
  <link rel="dns-prefetch" href="https://avatars3.githubusercontent.com">
  
  <link rel="stylesheet" type="text/css" href="/./style/main.css">
	<link rel="shortcut icon" href="/favicon.ico" title="Favicon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<title>a simple PL0 compiler</title>
  
  <script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?awwssw1snsnsnn1ndndnndnd99j";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();
  </script>
  
  
    <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/123456.js","daovoice");daovoice('init',{app_id: "123456"});daovoice('update');
  </script>
  
</head>
<body>
  <canvas id="pattern-placeholder" height="230"></canvas>
<div class="navbar-header">
  <a class="blog-title" href="/">Hexo</a>
  <a class="face-img" href="/">
    <img src="https://raw.githubusercontent.com/AlfredZee/image/master/1d28d196dac6e3960a2697478b981ac2.jpg">
  </a>
</div>
<main>
  <div class="article-title">
    
  
  <h1 class="title">
    a simple PL0 compiler
  </h1>
  


    <ul class="article-info">
      <li>
        å‘å¸ƒ
        <time datetime="2019-03-01T16:00:00.000Z" itemprop="datePublished">2019-03-02</time>
      </li>
      <li>
        
    æ›´æ–° <time datetime="2019-05-13T08:01:41.720Z" itemprop="dateUpdated">2019-05-13</time>

      </li>
      <li id="busuanzi_container_page_pv">
        é˜…è¯» <span id="busuanzi_value_page_pv"></span>
      </li>
    </ul>
  </div>
  <div class="container">
    <div class="article">
      <div class="content">
        
        <h1 id="ç¼–è¯‘åŸç†è¯¾ç¨‹è®¾è®¡â€“ç”¨Cä»é›¶å¼€å§‹å®ç°ä¸€ä¸ªPLï¼ç¼–è¯‘å™¨"><a href="#ç¼–è¯‘åŸç†è¯¾ç¨‹è®¾è®¡â€“ç”¨Cä»é›¶å¼€å§‹å®ç°ä¸€ä¸ªPLï¼ç¼–è¯‘å™¨" class="headerlink" title="ç¼–è¯‘åŸç†è¯¾ç¨‹è®¾è®¡â€“ç”¨Cä»é›¶å¼€å§‹å®ç°ä¸€ä¸ªPLï¼ç¼–è¯‘å™¨"></a>ç¼–è¯‘åŸç†è¯¾ç¨‹è®¾è®¡â€“ç”¨Cä»é›¶å¼€å§‹å®ç°ä¸€ä¸ªPLï¼ç¼–è¯‘å™¨</h1><hr>
<p><strong>copyright: å¾æ¸Š å¤§è¿ç†å·¥å¤§å­¦ç”µä¿¡å­¦éƒ¨</strong></p>
<p><strong>gitbub: Tiipitz.github.io</strong></p>
<p><strong>reference: ç¼–è¯‘åŸç†ï¼ˆç¬¬ä¸‰ç‰ˆï¼‰ ç‹ç”ŸåŸç­‰ æ¸…åå¤§å­¦å‡ºç‰ˆç¤¾</strong></p>
<p><strong>time: 2019-3-2</strong></p>
<p><strong>QQ: 1239820340ï¼ˆè”ç³»è¯·æ³¨æ˜åŸå› ï¼‰</strong></p>
<hr>
<h2 id="å‰è¨€"><a href="#å‰è¨€" class="headerlink" title="å‰è¨€"></a>å‰è¨€</h2><p>ã€€ã€€æœ¬ç¼–è¯‘å™¨çš„å®ç°ä¸»è¦å‚è€ƒäº†æ¸…åå¤§å­¦ç‹ç”ŸåŸç­‰ç¼–è‘—çš„ç¼–è¯‘åŸç†ï¼ˆç¬¬ä¸‰ç‰ˆï¼‰ï¼Œæƒå¨å‚è€ƒä»£ç å¯è§è¯¥ä¹¦ç¬¬370é¡µï¼Œä»¥ä¸‹å†…å®¹å‡ä¸ºæœ¬äººåœ¨ä»”ç»†ç ”è¯»å…¶ä»£ç å(çº¦èŠ±äº†è¿‘10å¤©ï¼‰ï¼ŒæŒ‰å…¶æ€»ä½“è®¾è®¡æ€æƒ³ä¸€æ­¥ä¸€æ­¥ä»é›¶å¼€å§‹å¼€å§‹æ­å»ºå®ç°ï¼ˆæ•°å‘¨ï¼‰ï¼Œé˜…è¯»æœ¬ç¯‡åšå®¢å¯ä»¥èŠ‚çœæ‚¨åˆæ¬¡æ­å»ºç¼–è¯‘å™¨çš„æ—¶é—´ï¼ŒæŒæ¡ç¼–è¯‘å™¨çš„æ€»ä½“è®¾è®¡æ€è·¯ï¼Œä½†æœ¬æ–‡ä¸ä¼šå¯¹åŸè¯­è¨€æ–‡æ³•ç­‰åšå‡ºä»”ç»†çš„é˜è¿°ï¼Œéœ€è¦æ‚¨å¯¹PLï¼è¯­è¨€è¯­æ³•æœ‰ä¸€å®šçš„äº†è§£ï¼Œä½œè€…èƒ½åŠ›æœ‰é™ï¼Œå¦‚æœ‰é”™è¯¯è¯·è”ç³»å‘ŠçŸ¥æ›´æ­£ï¼Œè°¢è°¢ã€‚</p>
<h2 id="è¯æ³•åˆ†æ"><a href="#è¯æ³•åˆ†æ" class="headerlink" title="è¯æ³•åˆ†æ"></a>è¯æ³•åˆ†æ</h2><p>ã€€ã€€é¦–å…ˆæˆ‘ä»¬ä»è¯æ³•åˆ†æå…¥æ‰‹ï¼Œè¯æ³•åˆ†æçš„ä¸»è¦åŠŸèƒ½æ˜¯æ‰«æä¸€éæºç¨‹åºï¼Œè¯†åˆ«å•è¯ã€‚å•è¯ä¸»è¦æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯ç”¨æˆ·è‡ªå®šä¹‰æ ‡è¯†ç¬¦ï¼Œå¦ä¸€ç§æ˜¯è¯¥è¯­è¨€ä¿ç•™çš„ç¬¦å·ï¼ŒåŒ…æ‹¬ï¼‡ï¼‹ï¼‡ï¼Œï¼‡ï¼ï¼‡ç­‰çš„å•å­—ç¬¦å’Œä¿ç•™å­—ï¼ˆå…³é”®å­—ï¼‰ã€‚</p>
<p>ã€€ã€€å¯¹äºåè€…ï¼Œæˆ‘ä»¬è¦ä¸æ–­çš„å°†æ‰«æåˆ°çš„ç¬¦å·å’Œä¿ç•™ç¬¦å·ç›¸æ¯”å¯¹ï¼Œéœ€è¦è€ƒè™‘ä½¿ç”¨åˆé€‚çš„æ•°æ®ç»“æ„æ¥å­˜å‚¨ï¼Œæˆ‘ä»¬å¯ä»¥äº‹å…ˆå°†ä¿ç•™ç¬¦å·å­˜å‚¨èµ·æ¥ï¼Œé€šè¿‡æ¯”ç…§æŸ¥è¡¨çš„æ–¹å¼æ¥åˆ¤æ–­æ‰«æåˆ°çš„ç¬¦å·çš„ç±»åˆ«ã€‚</p>
<p>ã€€ã€€æˆ‘ä»¬åˆ©ç”¨æšä¸¾çš„æ–¹å¼è§„å®šç¬¦å·çš„ç±»åˆ«ï¼š</p>
<pre><code>enum symbol {
nul,      ident,    number,    plussym,   minussym,
times,    slash,       oddsym,       eql,       neq,
lss,      leq,      gtr,        geq,       lparen,
rparen,   comma,   semicolon,  period,    becomes,
beginsym, endsym,   ifsym,     thensym,   whilesym,
writesym, readsym,  dosym,     callsym,   constsym,
varsym,   procsym,  
};

è¯´æ˜ï¼šå¤§å¤šæ•°åç§°å¯è”æƒ³è‹±æ–‡ç®€å†™å¾—çŸ¥æ„ä¹‰
</code></pre><p>ã€€ã€€å¯¹äºå•å­—ç¬¦ï¼Œæˆ‘ä»¬ç›´æ¥å°†å•å­—ç¬¦çš„ASCIIå€¼æ˜ å°„åˆ°ç±»åˆ«ï¼š</p>
<pre><code>single[&apos;+&apos;] = plussym;
single[&apos;-&apos;] = minussym;
single[&apos;*&apos;] = times;
single[&apos;(&apos;] = lparen;
single[&apos;)&apos;] = rparen;
single[&apos;=&apos;] = eql;
single[&apos;,&apos;] = comma;
single[&apos;.&apos;] = period;
single[&apos;#&apos;] = neq;
single[&apos;;&apos;] = semicolon;
</code></pre><p>ã€€ã€€å¯¹äºä¿ç•™å­—ï¼Œæˆ‘ä»¬é€ä¸ªå°†å…¶æŒ‰å‡åºçš„æ–¹å¼å­˜å‚¨åˆ°äºŒç»´æ•°ç»„ä¸­ï¼ŒäºŒåˆ†æŸ¥æ‰¾å¾—åˆ°å…¶åºå·å€¼ï¼Œç„¶åæ ¹æ®åºå·å€¼æ˜ å°„åˆ°ç±»åˆ«ã€‚</p>
<pre><code>strcpy(key[0],&quot;begin&quot;);
strcpy(key[1],&quot;call&quot;);
strcpy(key[2],&quot;const&quot;);
strcpy(key[3],&quot;do&quot;);
strcpy(key[4],&quot;end&quot;);
strcpy(key[5],&quot;if&quot;);
strcpy(key[6],&quot;odd&quot;);
strcpy(key[7],&quot;procedure&quot;);
strcpy(key[8],&quot;read&quot;);
strcpy(key[9],&quot;then&quot;);
strcpy(key[10],&quot;var&quot;);
strcpy(key[11],&quot;while&quot;);
strcpy(key[12],&quot;write&quot;);
æ ¹æ®ä¿ç•™å­—è¡¨è®¾ç½®æ¯”ç…§è¡¨ï¼Œå‡åºæ’åˆ—ä¾¿äºäºŒåˆ†æŸ¥æ‰¾æ¯”ç…§

keyword[0] = beginsym;
keyword[1] = callsym;
keyword[2] = constsym;
keyword[3] = dosym;
keyword[4] = endsym;
keyword[5] = ifsym;
keyword[6] = oddsym;
keyword[7] = procsym;
keyword[8] = readsym;
keyword[9] = thensym;
keyword[10] = varsym;
keyword[11] = whilesym;
keyword[12] = writesym;
</code></pre><p>ã€€ã€€äºæ­¤æˆ‘ä»¬è§£å†³äº†ä¿ç•™ç¬¦å·çš„å­˜å‚¨è¯†åˆ«é—®é¢˜ã€‚ä¸‹ä¸€æ­¥æˆ‘ä»¬å¼€å§‹ç€æ‰‹è®¾è®¡æ‰«æå™¨ï¼ˆï½“ï½ƒï½ï½ï½ï½…ï½’ï¼‰ã€‚
ã€€ã€€
ã€€</p>
<p>ã€€ã€€æ‰«æå™¨æˆ‘ä»¬å¯ä»¥åˆ†ä¸ºä¸¤å¤§éƒ¨åˆ†ï¼Œå…¶ä¸€æ˜¯è¯»å–ä¸€è¡Œçš„è¾“å…¥ï¼Œå¹¶ä¸”ç¼“å­˜ï¼Œä¸ºå¦ä¸€éƒ¨åˆ†æœåŠ¡ï¼Œè€Œå¦ä¸€éƒ¨åˆ†æŒ‡çš„å°±æ˜¯å°†è¯¥è¡Œçš„ç¼“å­˜åˆ†è§£æˆä¸€ä¸ªä¸€ä¸ªçš„ç¬¦å·ï¼ˆå•è¯ï¼‰ã€‚</p>
<p>ã€€ã€€æˆ‘ä»¬å¯ä»¥è¿™æ ·è®¾è®¡ï¼Œä»¥æ‰«æç¬¦å·ä¸ºä¸»ï¼Œè°ƒç”¨è¿›è¡Œè¡Œç¼“å­˜çš„å‡½æ•°ï¼ŒåŒæ—¶ï¼Œæˆ‘ä»¬ç»™è¡Œç¼“å­˜å‡½æ•°åˆ†é…ä¸€äº›é¢å¤–çš„ä»»åŠ¡ï¼šå¦‚æœè¯¥è¡Œæœªå¤„ç†å®Œï¼Œåˆ™è¯¥å‡½æ•°æ‰§è¡Œä»è¡Œç¼“å­˜ä¸­è¯»å–ä¸‹ä¸€ä¸ªå­—ç¬¦çš„åŠŸèƒ½ã€‚äºæ˜¯æˆ‘ä»¬å…ˆç»™å‡ºä»¥ä¸‹ç¨‹åºï¼š</p>
<pre><code>/*    è¡Œç¼“å­˜å¹¶è¯»å–ä¸€ä¸ªå­—ç¬¦    */
int getch(){
    if(firstp == lastp){
        if(feof(fin)){
            printf(&quot;åˆ°è¾¾æ–‡ä»¶æœ«å°¾\n&quot;);
            return -1;
        }
        firstp = lastp = 0;
        fprintf(fout, &quot;%d &quot;, cx);
        //æ¯åˆ°æ–°çš„ä¸€è¡Œåˆå§‹åŒ–chä¸ºç©º
        ch = &apos; &apos;;
        //æ–‡ä»¶è¾“åˆ°æœ€åå¿…é¡»æ¢è¡Œ
        while(ch != 10){
            //å¦‚æœæ˜¯è¯»åˆ°æ–‡ä»¶æœ«å°¾
            if(EOF == fscanf(fin, &quot;%c&quot;, &amp;ch)){
                line[lastp] = 0;
                break;
            }
            //å†™åˆ°æ–‡ä»¶ä¸­
            printf(&quot;%c&quot;, ch);
            fprintf(fout, &quot;%c&quot;, ch);
            //å†™åˆ°ç¼“å­˜ä¸­
            line[lastp] = ch;
            lastp++;
        }
        //æ¢è¡Œå†™åˆ°æ–‡ä»¶ä¸­
        fprintf(fout, &quot;\n&quot;);
    }
    //å¼€å§‹è¯»å–æ¯è¡Œçš„ç¼“å­˜ï¼Œå°†å­—ç¬¦ä¸€ä¸ªä¸€ä¸ªå­˜å…¥ch
    ch = line[firstp];
    firstp++;
    return 0;
}
</code></pre><p>ã€€ã€€è€Œå¯¹äºä¸»è°ƒå‡½æ•°ï¼Œé€šè¿‡è°ƒç”¨ä¸Šè¿°åŠŸèƒ½ï¼Œå¯ä»¥è·å¾—ä¸€ä¸²è¿ç»­çš„å­—ç¬¦è¾“å…¥ï¼Œå³ç¬¦å·çš„ç¼“å­˜ï¼Œå†é…åˆåˆ†æ”¯è¯­å¥å»åˆ¤åˆ«å…ˆå‰å®šä¹‰çš„ç¬¦å·çš„ç±»å‹ï¼Œå³å¯ä»¥å®Œæˆè¯æ³•åˆ†æçš„åŠŸèƒ½ï¼Œæœ€åæˆ‘ä»¬ç»™å‡ºå¦‚ä¸‹ç¨‹åºï¼š</p>
<pre><code>/*    è·å–ä¸€ä¸²ç¬¦å·    */
int getsymbol(){

    int cursor = 0;
    //è¯»å–ç¬¬ä¸€ä¸ªæœ‰æ•ˆå­—ç¬¦
    while(ch == &apos; &apos; || ch == 10 || ch == 9){
        getchOrReturn;
    }

    //åˆ¤æ–­æ˜¯å¦æ˜¯æ•°å­—
    if(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;){
        sym = number;
        //è®¡ç®—çœŸå®æ•°å€¼
        int value = 0;
        while(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;){
            value = 10 * value + ch - &apos;0&apos;;
            cursor++;
            getchOrReturn;
        }
        num = value;
        //å¦‚æœä½æ•°è¶Šç•Œ
        if(cursor &gt;= intmax){
            printf(&quot;æ•°å­—ä½æ•°è¿‡å¤š\n&quot;);
        }
    }

    //åˆ¤æ–­å˜é‡åæˆ–è€…ä¿ç•™å­—
    else if(ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;){
        //å­˜å…¥ç¬¦å·ä¸²åˆ°nameå­—ç¬¦ç¼“å­˜æ•°ç»„
        while((ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;) || (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;)){
            if(cursor &lt; namemax){
                name[cursor] = ch;
                cursor++;
            }
            getchOrReturn;
        }
        name[cursor] = 0;
        //äºŒåˆ†æœç´¢åˆ¤æ–­æ˜¯å¦æ˜¯ä¿ç•™å­—
        int i = 0, j = keywordnum - 1;
        int k;
        do{
            k = (i + j) / 2;
            if(strcmp(name, key[k]) &lt;= 0)
                j = k - 1;
            if(strcmp(name, key[k]) &gt;= 0)
                i = k + 1;
        }while(i &lt;= j);
        //å¦‚æœæ˜¯ä¿ç•™å­—
        if(i - 1 &gt; j){
            sym = keyword[k];
        }
        //å¦‚æœæ˜¯æ ‡è¯†ç¬¦
        else {
            sym = ident;
        }
    }

    //åˆ¤æ–­æ˜¯å¦æ˜¯èµ‹å€¼ç¬¦å·
    else if(&apos;:&apos; == ch){
        getchOrReturn;
        if(&apos;=&apos; == ch){
            sym = becomes;
            getchOrReturn;
        }
        else 
            sym = nul;
    }

    //åˆ¤æ–­æ˜¯å¦æ˜¯å°äºæˆ–å°äºç­‰äº
    else if(&apos;&lt;&apos; == ch){
        getchOrReturn;
        if(&apos;=&apos; == ch){
            sym = leq;
            getchOrReturn;
        }
        else 
            sym = lss;

    }

    //åˆ¤æ–­æ˜¯å¦æ˜¯å¤§äºæˆ–å¤§äºç­‰äº
    else if(&apos;&gt;&apos; == ch){
        getchOrReturn;
        if(&apos;=&apos; == ch){
            sym = geq;
            getchOrReturn;
        }
        else 
            sym = gtr;
    }

    //defaultä¸ºå•å­—ç¬¦å·
    else {
        sym = single[ch];
        if(sym != period)
            getchOrReturn;
    }
    return 0;
}
</code></pre><h2 id="è¯­æ³•åˆ†æ"><a href="#è¯­æ³•åˆ†æ" class="headerlink" title="è¯­æ³•åˆ†æ"></a>è¯­æ³•åˆ†æ</h2><p>ã€€ã€€ä¸€éç¼–æ‰«çš„ç¼–è¯‘å™¨é€šè¿‡è¯­æ³•åˆ†æè°ƒç”¨è¯æ³•åˆ†ææ¥å®ç°ï¼Œé€’å½’ä¸‹é™çš„è¯­æ³•åˆ†æè€ƒè™‘çš„æ˜¯ä½ å½“å‰è¯»å–äº†ä¸€ä¸ªç¬¦å·ï¼Œæ ¹æ®è¿™ä¸ªç¬¦å·ç±»åˆ«ï¼Œä½ ä¸‹ä¸€ä¸ªåº”è¯¥è¯»å–çš„ç¬¦å·åº”è¯¥æ˜¯ä»€ä¹ˆç±»åˆ«ã€‚</p>
<p>ã€€ã€€æˆ‘ä»¬ä»¥å¸¸é‡å¤„ç†è¯­æ³•ä¸ºä¾‹ï¼Œè¯»å–äº†å¸¸é‡å£°æ˜ç¬¦å·const,æˆ‘ä»¬æ¥ä¸‹æ¥éœ€è¦ä¸€ä¸ªidentï¼Œç„¶åæ˜¯=ï¼Œå†æ˜¯æ•°å€¼ï¼Œæœ€åæˆ‘ä»¬å†™å…¥åå­—è¡¨ï¼Œåå­—è¡¨æ˜¯ç”¨æ¥å­˜å‚¨ç”¨æˆ·è‡ªå®šä¹‰çš„æ ‡è¯†ç¬¦çš„å€¼ï¼Œåœ°å€ï¼Œç±»å‹ç­‰å†…å®¹ï¼Œäºæ˜¯æˆ‘ä»¬ç»™å‡ºä¸‹é¢çš„å‡½æ•°ï¼š</p>
<pre><code>/*    å¸¸é‡å£°æ˜å¤„ç†    */
int constdeclaration(int* ptx, int lev, int* pdx){
    //è¯­æ³•åº”è¯¥ä¸º const ident = num;
    //constå·²ç»è¯»å–ï¼Œå¼€å§‹åˆ†æåéƒ¨è¯­æ³•
    if(sym == ident){
        getsymbolOrReturn;
        if(sym == eql){
            getsymbolOrReturn;
            if(sym == number){
                enter(constant, ptx, lev, pdx);    //å†™å…¥è¡¨ä¸­
                getsymbolOrReturn;
            }
            else{
                printf(&quot;constç¼ºå°‘æ•°å­—\n&quot;);
            }
        }
        else {
            printf(&quot;constç¼ºå°‘ç­‰å·\n&quot;);
        }
    }
    else 
        printf(&quot;constç¼ºå°‘æ ‡è¯†ç¬¦\n&quot;);
    return 0;
}
</code></pre><p>ã€€ã€€ç›¸åº”çš„æˆ‘ä»¬å¯ä»¥ç»™å‡ºæ•°æ®ç±»å‹å’Œåå­—è¡¨çš„ç±»å‹ç»“æ„ï¼š</p>
<pre><code>/*    æ•°æ®ç±»å‹      */
enum object{
    constant,
    variable,
    procedure,
};

/*    åå­—è¡¨ç»“æ„    */
struct tablestruct{
    char name[namemax];    //    åç§°
    enum object kind;    //ç±»å‹
    int val;    //æ•°å€¼
    int level;    //æ‰€å¤„å±‚
    int adr;    //åœ°å€
    int size;    //æ•°æ®ç©ºé—´
};
</code></pre><p>ã€€ã€€åŒç†ï¼ŒæŒ‰ç…§æˆ‘ä»¬å®šä¹‰å¥½çš„è¯­æ³•ï¼Œé©¬ä¸Šå°±å¯ä»¥ç»™å‡ºå„ç±»å¤„ç†ï¼Œä»¥ä¸‹ä»£ç å‡æœ‰è¯¦ç»†æ³¨é‡Šï¼Œæ‰€ä»¥ä¸å±•å¼€è®¨è®ºï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯¹äºå£°æ˜çš„å¤„ç†ï¼Œå‡ä½¿ç”¨åˆ†æ”¯è¯­å¥æ¥å¤„ç†é”™è¯¯çš„è¯­æ³•ï¼Œè€Œå¯¹äºå…¶ä½™çš„è¯­æ³•é”™è¯¯ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªè¡¥æ•‘å‡½æ•°æ¥å¤„ç†ï¼Œå…¶åŠŸèƒ½å¤§æ¦‚æ˜¯é¦–å…ˆæˆ‘ä»¬æœ‰ä¸€ä¸ªåˆæ³•çš„åè·Ÿé›†åˆï¼Œæ¯æ¬¡è¯»å–ä¸€ä¸ªç¬¦å·ï¼Œæˆ‘ä»¬éƒ½ä¼šè·Ÿæ–°åè·Ÿé›†åˆçš„åˆæ³•å…ƒç´ ï¼Œå¦‚æœä¸‹ä¸€ä¸ªæ‰«æçš„ç¬¦å·ä¸åœ¨åè·Ÿé›†åˆä¸­ï¼Œæˆ‘ä»¬å°†é‡‡å–è¡¥æ•‘æªæ–½ï¼šä¸æ–­çš„å‘ä¸‹è¯»å–ç¬¦å·ç›´åˆ°è¯¥ç¬¦å·æ˜¯åˆæ³•çš„ã€‚ä¸‹é¢ç»™å‡ºå„å¤„ç†å‡½æ•°ã€‚</p>
<pre><code>/*    å˜é‡å£°æ˜å¤„ç†    */
int vardeclaration(int* ptx, int lev, int* pdx){
    //è¯­æ³•åº”è¯¥ä¸º var ident;
    //varå·²ç»è¯»å–ï¼Œå¼€å§‹åˆ†æåéƒ¨è¯­æ³•
    if(sym == ident){
        enter(variable, ptx, lev, pdx);
        getsymbolOrReturn;
    }
    else
        printf(&quot;varç¼ºå°‘æ ‡è¯†ç¬¦\n&quot;);
    return 0;
}


/*    å› å­å¤„ç†    */
int factor(bool* fsys,int* ptx,int lev){
    //å› å­è¦ä¹ˆæ˜¯æ ‡è¯†ç¬¦ï¼Œè¦ä¹ˆæ˜¯è¡¨è¾¾å¼ï¼Œè¦ä¹ˆæ˜¯æ•°
    //Fâ†’(E)|ident|num
    int i;
    bool nxtsys[symnum];
    testOrReturn(facbegsys,fsys,24);    //æµ‹è¯•åè·Ÿç¬¦å·æ˜¯å¦åˆæ³•
    while(inset(sym,facbegsys)){
        //æ˜¯æ ‡è¯†ç¬¦
        if(sym == ident){
            //è¿”å›åºå·
            i = position(name,* ptx);
            if(i == 0){
                printf(&quot;æ ‡è¯†ç¬¦ä¸å­˜åœ¨&quot;);
            }
            //ç”Ÿæˆæœºå™¨ä»£ç 
            else{
                switch(table[i].kind){
                    //å¸¸é‡æ ‡è¯†ç¬¦
                    case constant:
                        getcodeOrReturn(lit, 0, table[i].val);
                        break;
                    //å˜é‡æ ‡è¯†ç¬¦
                    case variable:
                        getcodeOrReturn(lod, lev - table[i].level, table[i].adr);
                        break;
                    //è¿‡ç¨‹æ ‡è¯†ç¬¦
                    case procedure:
                        printf(&quot;æ ‡è¯†ç¬¦ä¸ºè¿‡ç¨‹&quot;);
                        break;
                }
            }
            getsymbolOrReturn;
        }
        else{
            //æ•°
            if(sym == number){
                if(num &gt; amax){
                    printf(&quot;æ•°å­—è¿‡å¤§&quot;);
                    num = 0;
                }
                //ç”Ÿæˆæœºå™¨ä»£ç 
                getcodeOrReturn(lit,0,num);
                getsymbolOrReturn;
            }
            //è¡¨è¾¾å¼
            //Fâ†’(E)
            else{
                //è¯†åˆ«ï¼ˆ
                if(sym == lparen){
                    getsymbolOrReturn;
                    //æ›´æ–°åè·Ÿç¬¦å·é›†
                    memcpy(nxtsys, fsys, sizeof(bool) * symnum);
                    nxtsys[rparen] = true;
                    //è°ƒç”¨è¡¨è¾¾å¼å¤„ç†
                    expressionOrReturn(nxtsys, ptx, lev);
                    //è°ƒç”¨ç»“æŸè¯†åˆ«å³æ‹¬å·
                    if(sym == rparen){
                        getsymbolOrReturn;
                    }
                    else{
                        printf(&quot;Eåç¼ºå°‘)&quot;);
                    }
                }
                testOrReturn(fsys, facbegsys, 23);
            }
        }
    }
    return 0;
}


/*    é¡¹å¤„ç†    */
int term(bool* fsys,int* ptx,int lev){
    //Tâ†’T*F|T/F|F
    enum symbol top;
    bool nxtsys[symnum];
    memcpy(nxtsys,fsys,sizeof(bool) * symnum);
    nxtsys[times] = true;
    nxtsys[slash] = true;
    //å¤„ç†é¦–ä¸ªå› å­F
    factorOrReturn(nxtsys,ptx,lev);
    //å¤„ç†å®Œå› å­Få
    while(sym == times||sym == slash){
        top = sym;
        getsymbolOrReturn;
        //å¤„ç†å› å­F
        factorOrReturn(nxtsys,ptx,lev);
        //ä¹˜æ³•
        if(top == times){
            getcodeOrReturn(opr,0,4);
        }
        //é™¤æ³•
        else{
            getcodeOrReturn(opr,0,5);
        }
    }
    return 0;
}

/*    è¡¨è¾¾å¼å¤„ç†    */
int expression(bool* fsys,int* ptx,int lev){
    //firsté›†ä¸­å¯èƒ½æœ‰æ­£è´Ÿå·
    //Eâ†’E+T|T
    enum symbol eop;    
    bool nxtsys[symnum];
    //å¦‚æœæ˜¯æ­£è´Ÿå·
    if(sym == plussym || sym == minussym){
        eop = sym;    //ä¿å­˜ç¬¦å·
        getsymbolOrReturn;
        //è·Ÿæ–°åè·Ÿé›†
        memcpy(nxtsys, fsys, sizeof(bool) * symnum);
        nxtsys[plussym] = true;
        nxtsys[minussym] = true;
        //å¤„ç†é¡¹T
        termOrReturn(nxtsys,ptx,lev);
        //å¦‚æœä¸ºè´Ÿ
        if(eop = minussym){
            getcodeOrReturn(opr,0,1);
        }
    }
    //ç›´æ¥æ›´æ–°åè·Ÿé›†
    else{
        memcpy(nxtsys, fsys, sizeof(bool) * symnum);
        nxtsys[plussym] = true;
        nxtsys[minussym] = true;
        termOrReturn(nxtsys,ptx,lev);
    }
    //å¤„ç†å®Œé¡¹Tä¹‹å
    while(sym == plussym || sym == minussym){
        eop = sym;
        getsymbolOrReturn;
        //åœ¨è¿›è¡Œé¡¹çš„åˆ†æ
        memcpy(nxtsys, fsys, sizeof(bool) * symnum);
        nxtsys[plussym] = true;
        nxtsys[minussym] = true;
        termOrReturn(nxtsys, ptx, lev);
        //åŠ æ³•
        if(eop == plussym){
            getcodeOrReturn(opr,0,2);
        }
        //å‡æ³•
        else{
            getcodeOrReturn(opr,0,3);
        }
    }
    return 0;
}


/*    æ¡ä»¶å¤„ç†    */
int condition(bool* fsys,int* ptx,int lev){
    enum symbol relop;
    bool nxtsys[symnum];
    //%2
    if(sym == oddsym){
        getsymbolOrReturn;
        expressionOrReturn(fsys,ptx,lev);
        getcodeOrReturn(opr,0,6);
    }
    //è¡¨è¾¾å¼
    else{
        memcpy(nxtsys, fsys, sizeof(bool) * symnum);
        nxtsys[eql] = true;
        nxtsys[neq] = true;
        nxtsys[lss] = true;
        nxtsys[leq] = true;
        nxtsys[gtr] = true;
        nxtsys[geq] = true;
        //è¡¨è¾¾å¼å¤„ç†
        expressionOrReturn(fsys,ptx,lev);
        if(sym != eql &amp;&amp; sym != neq &amp;&amp; sym != lss &amp;&amp; sym != leq &amp;&amp; sym != gtr &amp;&amp; sym != geq){
            printf(&quot;éœ€è¦æ¯”è¾ƒç¬¦å·&quot;);
        }
        else{
            relop = sym;
            //å»ä¸‹ä¸€ä¸ªç¬¦å·å¹¶è¿›è¡Œè¡¨è¾¾å¼å¤„ç†
            getsymbolOrReturn;
            expressionOrReturn(fsys, ptx, lev);
            //æ ¹æ®relopç”Ÿæˆæœºå™¨ä»£ç 
            switch(relop){
                case eql:
                    getcodeOrReturn(opr,0,8);
                    break;
                case neq:
                    getcodeOrReturn(opr,0,9);
                    break;
                case lss:
                    getcodeOrReturn(opr,0,10);
                    break;
                case geq:
                    getcodeOrReturn(opr,0,11);
                    break;
                case gtr:
                    getcodeOrReturn(opr,0,12);
                    break;
                case leq:
                    getcodeOrReturn(opr,0,13);
                    break;
            }
        }
    }
    return 0;
}
</code></pre><p>ã€€ã€€éœ€è¦æŒ‡å‡ºçš„æ˜¯ï¼Œä¸Šè¿°å‡½æ•°ä¸­æœ‰å¤§é‡çš„getcodeå‡½æ•°ï¼Œè¯¥å‡½æ•°æ‰§è¡Œçš„æ˜¯æ ¹æ®è¯­æ³•ç”Ÿæˆæœºå™¨ä»£ç ï¼Œä¹Ÿå°±æ˜¯è¯´æœ¬PL0æ˜¯è¯­æ³•å’Œè¯­ä¹‰ç›¸ç»“åˆçš„ç¼–è¯‘å™¨ï¼Œåœ¨åˆ†æè¯­æ³•çš„æ—¶å€™å°±ç›¸åº”çš„è¾“å‡ºäº†æœºå™¨ä»£ç ï¼Œä¾›ä¸‹ä¸€æ¨¡å—è§£é‡Šæ‰§è¡Œä½¿ç”¨ï¼Œå‡½æ•°è¾ƒä¸ºç®€å•ï¼Œé€šè¿‡çœ‹å…¥å£å‚æ•°ï¼ˆæ“ä½œï¼Œå±‚æ¬¡ï¼Œæ“ä½œåºå·ï¼‰å³å¯çŒœæƒ³å…¶å†…éƒ¨å®ç°æ•…ä¸ç»™å‡ºå…·ä½“å®ç°ä»£ç ä»…ç»™å‡ºå…¶ç±»å‹ç»“æ„ï¼š</p>
<pre><code>/*    è™šæ‹Ÿæœºä»£ç ç»“æ„    */
struct instruction{
    enum fct f;    //æŒ‡ä»¤
    int l;    //å±‚æ¬¡å·®
    int a;    
};
</code></pre><h2 id="è§£é‡Šæ‰§è¡Œ"><a href="#è§£é‡Šæ‰§è¡Œ" class="headerlink" title="è§£é‡Šæ‰§è¡Œ"></a>è§£é‡Šæ‰§è¡Œ</h2><p>ã€€ã€€ç”±ä¸Šä¸€æ®µæ–‡å­—å’Œgetcodeå‡½æ•°å¯çŸ¥ï¼Œä¸è¯æ³•åˆ†æç›¸åŒï¼Œè§£é‡Šæ‰§è¡Œçš„æ“ä½œä¹Ÿéœ€è¦ç”¨æšä¸¾å­˜å‚¨ï¼š</p>
<pre><code>/*     è™šæ‹Ÿæœºä»£ç       */
enum fct{
    lit,    opr,    lod,
    sto,    cal,    inte,
    jmp,   jpc,
};
</code></pre><p>ã€€ã€€æœ¬ç¼–è¯‘å™¨å®ç°çš„æ˜¯æ¨¡æ‹Ÿæ ˆå¤„ç†æœºçš„æ‰§è¡Œï¼Œé€šè¿‡è¯­æ³•è¯­ä¹‰åˆ†æç”Ÿæˆçš„ä»£ç ï¼Œä¸€è¡Œä¸€è¡Œçš„æ‰§è¡Œæ ˆçš„ç›¸å…³æ“ä½œï¼Œå¯¹ç†Ÿæ‚‰æ•°æ®ç»“æ„çš„æ‚¨ä¸€å®šç›¸å½“ç®€å•æ•…ä¸ä½œè¿‡å¤šè§£é‡Šï¼Œä¸‹é¢ç›´æ¥ç»™å‡ºä»£ç ï¼š</p>
<pre><code>void interpret(){
    int p,b,t;    //æŒ‡é’ˆï¼ŒåŸºå€ï¼Œæ ˆé¡¶
    struct instruction i;    //å­˜æ”¾æŒ‡ä»¤
    int s[stacksize];    //æ•°æ®æ ˆ
    printf(&quot;start pl0\n&quot;);
    //åˆå§‹åŒ–
    t = 0;
    b = 0;
    p = 0;
    s[0] = s[1] = s[2] = 0;
    //å¼€å§‹
    do{
        //å–ä¸€æ¡æŒ‡ä»¤
        i = code[p];
        p++;
        switch(i.f){
            //å–å€¼æ“ä½œ
            case lit:
                s[t] = i.a;    
                t++;
                break;
            //è¿ç®—æ“ä½œ
            case opr:
                switch (i.a){
                    case 0:
                        t = b;
                        p = s[t + 2];
                        b = s[t + 1];
                        break;
                    case 1:
                        s[t - 1] = -s[t - 1];
                        break;
                    case 2:
                        t--;
                        s[t - 1] = s[t - 1] + s[t];
                        break;
                    case 3:
                        t--;
                        s[t - 1] = s[t - 1] - s[t];
                        break;
                    case 4:
                        t--;
                        s[t - 1] = s[t - 1] * s[t];
                        break;
                    case 5:
                        t--;
                        s[t - 1] = s[t - 1] / s[t];
                        break;
                    case 6:
                        s[t - 1] = s[t - 1] % 2;
                        break;
                    case 8:
                        t--;
                        s[t - 1] = (s[t - 1] == s[t]);
                        break;
                    case 9:
                        t--;
                        s[t - 1] = (s[t - 1] != s[ t ]);
                        break;
                    case 10:
                        t--;
                        s[t - 1] = (s[ t- 1] &lt; s[ t ]);
                        break;
                    case 11:
                        t--;
                        s[t - 1] = (s[t - 1] &gt;= s[t]);
                        break;
                    case 12:
                        t--;
                        s[t - 1] = (s[t - 1] &gt; s[t]);
                        break;
                    case 13:
                        t--;
                        s[t - 1] = (s[t - 1] &lt;= s[t]);
                        break;
                    case 14:
                        printf(&quot;%d&quot;, s[t - 1]);
                        fprintf(fr, &quot;%d&quot;, s[t - 1]);
                        t--;
                        break;
                    case 15:
                        printf(&quot;\n&quot;);
                        fprintf(fr, &quot;\n&quot;);
                        break;
                    case 16:
                        printf(&quot;?&quot;);
                        fprintf(fr, &quot;?&quot;);
                        scanf(&quot;%d&quot;,&amp;(s[t]));
                        fprintf(fr, &quot;%d\n&quot;, s[t]);
                        t++;
                        break;
                }
                break;
            //è£…è½½
            case lod:
                s[t] = s[base(i.l, s, b) + i.a];
                t++;
                break;
            //å­˜å‚¨
            case sto:
                t--;
                s[base(i.l, s, b) + i.a] = s[t];
                break;
            //è°ƒç”¨è¿‡ç¨‹
            case cal:
                s[t] = base(i.l,s,b);
                s[t + 1] = b;
                s[t + 2] = p;
                b = t;
                p = i.a;
                break;
            //å†…å­˜åˆ†é…
            case inte:
                t += i.a;
                break;
            //è·³è½¬
            case jmp:
                p = i.a;
                break;
            //æ¡ä»¶è·³è½¬
            case jpc:
                t --;
                if (s[t] == 0)
                {
                    p = i.a;
                }
                break;
        }
    }while (p != 0);
}
</code></pre><h2 id="ç»“è¯­"><a href="#ç»“è¯­" class="headerlink" title="ç»“è¯­"></a>ç»“è¯­</h2><p>ã€€ã€€æœ¬æ–‡ä»‹ç»äº†ä¸€ä¸ªä¸€éæ‰«æï¼Œæ ˆå¼è¿è¡Œçš„PL0ç¼–è¯‘å™¨çš„æ€»ä½“æ¡†æ¶å’Œè®¾è®¡è¿‡ç¨‹ï¼Œæœ¬è¯¾ç¨‹è®¾è®¡æœ€åå¾—åˆ†ä¸º90åˆ†ï¼Œç»å®éªŒå¯æ­£ç¡®è¿è¡Œé€’å½’å‡½æ•°ï¼Œæ˜¾ç¤ºè¾“å…¥é”™è¯¯ï¼Œæœ€åä¸å†ç»™å‡ºä¸»è°ƒå‡½æ•°å’Œå„ç»†èŠ‚å‡½æ•°ï¼Œå¦‚æœ‰éœ€è¦å¯è”ç³»æœ¬äººè·å–æºç ã€‚</p>

      </div>
        <div class="support-author">
          <p>æ„Ÿè°¢æ‚¨çš„é˜…è¯»ã€‚ ğŸ™
          <a href="https://888.com/index.html" target="_blank">å…³äºè½¬è½½è¯·çœ‹è¿™é‡Œ</a>
            <!--<a class="btn-pay"  href="#pay-modal">Â¥ æ‰“èµæ”¯æŒ</a>-->
          </p>
        </div>
        <!--
            <div class="like ">
              <div class="like-button">
                <a id="like-note" href="">
                  <i class="icon-heart"></i>å–œæ¬¢
                </a>
              </div>
              <span id="likes-count">256</span>
            </div>
        -->
        <div class="otherLink">
          <div class="previous">
          </div>
          <div class="next">
          </div>
        </div>
        <div class="comments" id="comments">
          
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  const gitalk = new Gitalk({
    clientID: '8888a8888',
    clientSecret: '8888886666666',
    repo: 'xxxx.github.io',
    owner: 'admin',
    admin: ['admin'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false
  })

  gitalk.render('comments');
</script>


        </div>
      </div>
    </div>
   </div>
</main>
<div class="footer">
  <div class="info">
    <p>
    <a href="https://hexo.io"> Hexo </a> å¼ºåŠ›é©±åŠ¨ |
      <a href="https://github.com/Youthink/hexo-themes-yearn"> Yearn </a>
      ä¸»é¢˜
    </p>
    <p>&copy;2018-2019 AlfredZeeçš„åšå®¢</p>
  </div>
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>//console
  var consoleConfig = '\næ¬¢è¿è®¿é—® https://hufangyun.com ï¼Œå›´è§‚å°çŒ¿å¤§åœ£çš„åšå®¢(ã¥ï½¡â—•â€¿â€¿â—•ï½¡)ã¥ï¼\n,\næœ¬åšå®¢ä½¿ç”¨ %cHexo%c æ­å»ºï¼Œåšå®¢ä¸»é¢˜ä¸ºå°çŒ¿å¤§åœ£å¼€å‘çš„ %chexo-themes-yearn%c ~~~ ğŸ‰ğŸ‰ğŸ‰ \n\næºç  https://github.com/Youthink/hexo-themes-yearn \n\nå¦‚æœå–œæ¬¢å¯ä»¥ star æ”¯æŒä¸€ä¸‹ â¤ï¸~\n,\næ‰«æä¸‹é¢çš„äºŒç»´ç ï¼Œåœ¨æ‰‹æœºä¸ŠæŸ¥çœ‹åšå®¢ï¼\n,https://static.hufangyun.com/blog-url-qrcode-180-180.png,\n æƒ³çŸ¥é“è¿™ä¸ªæ•ˆæœå¦‚ä½•å®ç°çš„ï¼Ÿåšå®¢å†…æœç´¢ console å½©è›‹ ğŸš€ ï¼\n'.split(',');
  var canConsole = true;
  var consoleInfo = (function(consoleConfig) {
  if (!canConsole || !consoleConfig || consoleConfig.length < 1) {
    return;
  }
  var consoleColor = '#6190e8';
  var _console;
  var backgroundTextStyle = 'padding: 1px 5px;color: #fff;background: ' + consoleColor + ';'
  var textStyle = 'color: ' + consoleColor + ';';

  consoleConfig.map(o => {
    var num = (o.match(/%c/g) || []).length;
    if(/^http(s)?:\/\//.test(o)) {
      console.log('%c     ', 'background: url(' + o + ') no-repeat left center;font-size: 180px;');
      return;
    }
    if (num > 0) {
      var logArguments = [];
      for (var i = 0; i < num; i++) {
        if (i % 2 === 0) {
          logArguments.push(backgroundTextStyle);
        } else {
          logArguments.push(textStyle);
        }
      }
      (_console = console).log.apply(_console, ['%c' + o, textStyle].concat(logArguments));
      return;
    }
    console.log('%c' + o, textStyle);
  });
}(consoleConfig));</script><script type="text/javascript" src="/./js/main.js"></script>

  <script src="//at.alicdn.com/t/font_159214_mvtxvg9me9.js"></script>
</body>
</html>
